<html>
<head>
<title>StdDraw.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(128,128,128); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(106,135,89); }
.s6 { color: rgb(128,128,128); font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
StdDraw.java</FONT>
</center></TD></TR></TABLE>
<pre>

<span class="s0">/************************************************************************* 
 *  Compilation:  javac StdDraw.java 
 *  Execution:    java StdDraw 
 * 
 *  Standard drawing library. This class provides a basic capability for 
 *  creating drawings with your programs. It uses a simple graphics model that 
 *  allows you to create drawings consisting of points, lines, and curves 
 *  in a window on your computer and to save the drawings to a file. 
 * 
 *  Todo 
 *  ---- 
 *    -  Add support for gradient fill, etc. 
 * 
 *  Remarks 
 *  ------- 
 *    -  don't use AffineTransform for rescaling since it inverts 
 *       images and strings 
 *    -  careful using setFont in inner loop within an animation - 
 *       it can cause flicker 
 * 
 *************************************************************************/</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">java.awt.*</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.awt.event.*</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.awt.geom.*</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.awt.image.*</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.io.*</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.net.*</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.util.LinkedList</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.util.TreeSet</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">javax.imageio.ImageIO</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">javax.swing.*</span><span class="s2">;</span><span class="s1"> 
 
</span><span class="s0">/** 
 *  &lt;i&gt;Standard draw&lt;/i&gt;. This class provides a basic capability for 
 *  creating drawings with your programs. It uses a simple graphics model that 
 *  allows you to create drawings consisting of points, lines, and curves 
 *  in a window on your computer and to save the drawings to a file. 
 *  &lt;p&gt; 
 *  For additional documentation, see &lt;a href=&quot;http://introcs.cs.princeton.edu/15inout&quot;&gt;Section 1.5&lt;/a&gt; of 
 *  &lt;i&gt;Introduction to Programming in Java: An Interdisciplinary Approach&lt;/i&gt; by Robert Sedgewick and Kevin Wayne. 
 * 
 *  @author Robert Sedgewick 
 *  @author Kevin Wayne 
 */</span><span class="s1"> 
</span><span class="s2">public final class </span><span class="s1">StdDraw </span><span class="s2">implements </span><span class="s1">ActionListener</span><span class="s2">, </span><span class="s1">MouseListener</span><span class="s2">, </span><span class="s1">MouseMotionListener</span><span class="s2">, </span><span class="s1">KeyListener { 
 
    </span><span class="s3">// pre-defined colors</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color BLACK      = Color.BLACK</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color BLUE       = Color.BLUE</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color CYAN       = Color.CYAN</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color DARK_GRAY  = Color.DARK_GRAY</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color GRAY       = Color.GRAY</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color GREEN      = Color.GREEN</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color LIGHT_GRAY = Color.LIGHT_GRAY</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color MAGENTA    = Color.MAGENTA</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color ORANGE     = Color.ORANGE</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color PINK       = Color.PINK</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color RED        = Color.RED</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color WHITE      = Color.WHITE</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color YELLOW     = Color.YELLOW</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Shade of blue used in Introduction to Programming in Java. 
     * It is Pantone 300U. The RGB values are approximately (9, 90, 166). 
     */</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color BOOK_BLUE       = </span><span class="s2">new </span><span class="s1">Color(  </span><span class="s4">9</span><span class="s2">,  </span><span class="s4">90</span><span class="s2">, </span><span class="s4">166</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color BOOK_LIGHT_BLUE = </span><span class="s2">new </span><span class="s1">Color(</span><span class="s4">103</span><span class="s2">, </span><span class="s4">198</span><span class="s2">, </span><span class="s4">243</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Shade of red used in Algorithms 4th edition. 
     * It is Pantone 1805U. The RGB values are approximately (150, 35, 31). 
     */</span><span class="s1"> 
    </span><span class="s2">public static final </span><span class="s1">Color BOOK_RED = </span><span class="s2">new </span><span class="s1">Color(</span><span class="s4">150</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// default colors</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">Color DEFAULT_PEN_COLOR   = BLACK</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">Color DEFAULT_CLEAR_COLOR = WHITE</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// current pen color</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">Color penColor</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// default canvas size is DEFAULT_SIZE-by-DEFAULT_SIZE</span><span class="s1"> 
    </span><span class="s2">private static final int </span><span class="s1">DEFAULT_SIZE = </span><span class="s4">512</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static int </span><span class="s1">width  = DEFAULT_SIZE</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static int </span><span class="s1">height = DEFAULT_SIZE</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// default pen radius</span><span class="s1"> 
    </span><span class="s2">private static final double </span><span class="s1">DEFAULT_PEN_RADIUS = </span><span class="s4">0.002</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// current pen radius</span><span class="s1"> 
    </span><span class="s2">private static double </span><span class="s1">penRadius</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// show we draw immediately or wait until next show?</span><span class="s1"> 
    </span><span class="s2">private static boolean </span><span class="s1">defer = </span><span class="s2">false;</span><span class="s1"> 
 
    </span><span class="s3">// boundary of drawing canvas, 5% border</span><span class="s1"> 
    </span><span class="s2">private static final double </span><span class="s1">BORDER = </span><span class="s4">0.05</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final double </span><span class="s1">DEFAULT_XMIN = </span><span class="s4">0.0</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final double </span><span class="s1">DEFAULT_XMAX = </span><span class="s4">1.0</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final double </span><span class="s1">DEFAULT_YMIN = </span><span class="s4">0.0</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final double </span><span class="s1">DEFAULT_YMAX = </span><span class="s4">1.0</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static double </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymax</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// for synchronization</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">Object mouseLock = </span><span class="s2">new </span><span class="s1">Object()</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">Object keyLock = </span><span class="s2">new </span><span class="s1">Object()</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// default font</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">Font DEFAULT_FONT = </span><span class="s2">new </span><span class="s1">Font(</span><span class="s5">&quot;SansSerif&quot;</span><span class="s2">, </span><span class="s1">Font.PLAIN</span><span class="s2">, </span><span class="s4">16</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// current font</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">Font font</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// double buffered graphics</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">BufferedImage offscreenImage</span><span class="s2">, </span><span class="s1">onscreenImage</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">Graphics2D offscreen</span><span class="s2">, </span><span class="s1">onscreen</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// singleton for callbacks: avoids generation of extra .class files</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">StdDraw std = </span><span class="s2">new </span><span class="s1">StdDraw()</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// the frame for drawing to the screen</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">JFrame frame</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// mouse state</span><span class="s1"> 
    </span><span class="s2">private static boolean </span><span class="s1">mousePressed = </span><span class="s2">false;</span><span class="s1"> 
    </span><span class="s2">private static double </span><span class="s1">mouseX = </span><span class="s4">0</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static double </span><span class="s1">mouseY = </span><span class="s4">0</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// queue of typed key characters</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">LinkedList&lt;Character&gt; keysTyped = </span><span class="s2">new </span><span class="s1">LinkedList&lt;Character&gt;()</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s3">// set of key codes currently pressed down</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">TreeSet&lt;Integer&gt; keysDown = </span><span class="s2">new </span><span class="s1">TreeSet&lt;Integer&gt;()</span><span class="s2">;</span><span class="s1"> 
   
 
    </span><span class="s3">// singleton pattern: client can't instantiate</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">StdDraw() { } 
 
 
    </span><span class="s3">// static initializer</span><span class="s1"> 
    </span><span class="s2">static </span><span class="s1">{ init()</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the window size to the default size 512-by-512 pixels. 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setCanvasSize() { 
        setCanvasSize(DEFAULT_SIZE</span><span class="s2">, </span><span class="s1">DEFAULT_SIZE)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Set the window size to w-by-h pixels. 
     * 
     * @param w the width as a number of pixels 
     * @param h the height as a number of pixels 
     * @throws a IllegalArgumentException if the width or height is 0 or negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setCanvasSize(</span><span class="s2">int </span><span class="s1">w</span><span class="s2">, int </span><span class="s1">h) { 
        </span><span class="s2">if </span><span class="s1">(w &lt; </span><span class="s4">1 </span><span class="s1">|| h &lt; </span><span class="s4">1</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;width and height must be positive&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        width = w</span><span class="s2">;</span><span class="s1"> 
        height = h</span><span class="s2">;</span><span class="s1"> 
        init()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">// init</span><span class="s1"> 
    </span><span class="s2">private static void </span><span class="s1">init() { 
        </span><span class="s2">if </span><span class="s1">(frame != </span><span class="s2">null</span><span class="s1">) frame.setVisible(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        frame = </span><span class="s2">new </span><span class="s1">JFrame()</span><span class="s2">;</span><span class="s1"> 
        offscreenImage = </span><span class="s2">new </span><span class="s1">BufferedImage(width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">BufferedImage.TYPE_INT_ARGB)</span><span class="s2">;</span><span class="s1"> 
        onscreenImage  = </span><span class="s2">new </span><span class="s1">BufferedImage(width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">BufferedImage.TYPE_INT_ARGB)</span><span class="s2">;</span><span class="s1"> 
        offscreen = offscreenImage.createGraphics()</span><span class="s2">;</span><span class="s1"> 
        onscreen  = onscreenImage.createGraphics()</span><span class="s2">;</span><span class="s1"> 
        setXscale()</span><span class="s2">;</span><span class="s1"> 
        setYscale()</span><span class="s2">;</span><span class="s1"> 
        offscreen.setColor(DEFAULT_CLEAR_COLOR)</span><span class="s2">;</span><span class="s1"> 
        offscreen.fillRect(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span><span class="s1"> 
        setPenColor()</span><span class="s2">;</span><span class="s1"> 
        setPenRadius()</span><span class="s2">;</span><span class="s1"> 
        setFont()</span><span class="s2">;</span><span class="s1"> 
        clear()</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// add antialiasing</span><span class="s1"> 
        RenderingHints hints = </span><span class="s2">new </span><span class="s1">RenderingHints(RenderingHints.KEY_ANTIALIASING</span><span class="s2">,</span><span class="s1"> 
                                                  RenderingHints.VALUE_ANTIALIAS_ON)</span><span class="s2">;</span><span class="s1"> 
        hints.put(RenderingHints.KEY_RENDERING</span><span class="s2">, </span><span class="s1">RenderingHints.VALUE_RENDER_QUALITY)</span><span class="s2">;</span><span class="s1"> 
        offscreen.addRenderingHints(hints)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// frame stuff</span><span class="s1"> 
        ImageIcon icon = </span><span class="s2">new </span><span class="s1">ImageIcon(onscreenImage)</span><span class="s2">;</span><span class="s1"> 
        JLabel draw = </span><span class="s2">new </span><span class="s1">JLabel(icon)</span><span class="s2">;</span><span class="s1"> 
 
        draw.addMouseListener(std)</span><span class="s2">;</span><span class="s1"> 
        draw.addMouseMotionListener(std)</span><span class="s2">;</span><span class="s1"> 
 
        frame.setContentPane(draw)</span><span class="s2">;</span><span class="s1"> 
        frame.addKeyListener(std)</span><span class="s2">;    </span><span class="s3">// JLabel cannot get keyboard focus</span><span class="s1"> 
        frame.setResizable(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span><span class="s2">;            </span><span class="s3">// closes all windows</span><span class="s1"> 
        </span><span class="s3">// frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);      // closes only current window</span><span class="s1"> 
        frame.setTitle(</span><span class="s5">&quot;Standard Draw&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        frame.setJMenuBar(createMenuBar())</span><span class="s2">;</span><span class="s1"> 
        frame.pack()</span><span class="s2">;</span><span class="s1"> 
        frame.requestFocusInWindow()</span><span class="s2">;</span><span class="s1"> 
        frame.setVisible(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">// create the menu bar (changed to private)</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">JMenuBar createMenuBar() { 
        JMenuBar menuBar = </span><span class="s2">new </span><span class="s1">JMenuBar()</span><span class="s2">;</span><span class="s1"> 
        JMenu menu = </span><span class="s2">new </span><span class="s1">JMenu(</span><span class="s5">&quot;File&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        menuBar.add(menu)</span><span class="s2">;</span><span class="s1"> 
        JMenuItem menuItem1 = </span><span class="s2">new </span><span class="s1">JMenuItem(</span><span class="s5">&quot; Save...   &quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        menuItem1.addActionListener(std)</span><span class="s2">;</span><span class="s1"> 
        menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S</span><span class="s2">,</span><span class="s1"> 
                                Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()))</span><span class="s2">;</span><span class="s1"> 
        menu.add(menuItem1)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">menuBar</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
   </span><span class="s0">/************************************************************************* 
    *  User and screen coordinate systems 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Set the x-scale to be the default (between 0.0 and 1.0). 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setXscale() { setXscale(DEFAULT_XMIN</span><span class="s2">, </span><span class="s1">DEFAULT_XMAX)</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the y-scale to be the default (between 0.0 and 1.0). 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setYscale() { setYscale(DEFAULT_YMIN</span><span class="s2">, </span><span class="s1">DEFAULT_YMAX)</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the x-scale (a 10% border is added to the values) 
     * @param min the minimum value of the x-scale 
     * @param max the maximum value of the x-scale 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setXscale(</span><span class="s2">double </span><span class="s1">min</span><span class="s2">, double </span><span class="s1">max) { 
        </span><span class="s2">double </span><span class="s1">size = max - min</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            xmin = min - BORDER * size</span><span class="s2">;</span><span class="s1"> 
            xmax = max + BORDER * size</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * Set the y-scale (a 10% border is added to the values). 
     * @param min the minimum value of the y-scale 
     * @param max the maximum value of the y-scale 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setYscale(</span><span class="s2">double </span><span class="s1">min</span><span class="s2">, double </span><span class="s1">max) { 
        </span><span class="s2">double </span><span class="s1">size = max - min</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            ymin = min - BORDER * size</span><span class="s2">;</span><span class="s1"> 
            ymax = max + BORDER * size</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * Set the x-scale and y-scale (a 10% border is added to the values) 
     * @param min the minimum value of the x- and y-scales 
     * @param max the maximum value of the x- and y-scales 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setScale(</span><span class="s2">double </span><span class="s1">min</span><span class="s2">, double </span><span class="s1">max) { 
        </span><span class="s2">double </span><span class="s1">size = max - min</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            xmin = min - BORDER * size</span><span class="s2">;</span><span class="s1"> 
            xmax = max + BORDER * size</span><span class="s2">;</span><span class="s1"> 
            ymin = min - BORDER * size</span><span class="s2">;</span><span class="s1"> 
            ymax = max + BORDER * size</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s3">// helper functions that scale from user coordinates to screen coordinates and back</span><span class="s1"> 
    </span><span class="s2">private static double  </span><span class="s1">scaleX(</span><span class="s2">double </span><span class="s1">x) { </span><span class="s2">return </span><span class="s1">width  * (x - xmin) / (xmax - xmin)</span><span class="s2">; </span><span class="s1">} 
    </span><span class="s2">private static double  </span><span class="s1">scaleY(</span><span class="s2">double </span><span class="s1">y) { </span><span class="s2">return </span><span class="s1">height * (ymax - y) / (ymax - ymin)</span><span class="s2">; </span><span class="s1">} 
    </span><span class="s2">private static double </span><span class="s1">factorX(</span><span class="s2">double </span><span class="s1">w) { </span><span class="s2">return </span><span class="s1">w * width  / Math.abs(xmax - xmin)</span><span class="s2">;  </span><span class="s1">} 
    </span><span class="s2">private static double </span><span class="s1">factorY(</span><span class="s2">double </span><span class="s1">h) { </span><span class="s2">return </span><span class="s1">h * height / Math.abs(ymax - ymin)</span><span class="s2">;  </span><span class="s1">} 
    </span><span class="s2">private static double   </span><span class="s1">userX(</span><span class="s2">double </span><span class="s1">x) { </span><span class="s2">return </span><span class="s1">xmin + x * (xmax - xmin) / width</span><span class="s2">;    </span><span class="s1">} 
    </span><span class="s2">private static double   </span><span class="s1">userY(</span><span class="s2">double </span><span class="s1">y) { </span><span class="s2">return </span><span class="s1">ymax - y * (ymax - ymin) / height</span><span class="s2">;   </span><span class="s1">} 
 
 
    </span><span class="s0">/** 
     * Clear the screen to the default color (white). 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">clear() { clear(DEFAULT_CLEAR_COLOR)</span><span class="s2">; </span><span class="s1">} 
    </span><span class="s0">/** 
     * Clear the screen to the given color. 
     * @param color the Color to make the background 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">clear(Color color) { 
        offscreen.setColor(color)</span><span class="s2">;</span><span class="s1"> 
        offscreen.fillRect(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span><span class="s1"> 
        offscreen.setColor(penColor)</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Get the current pen radius. 
     */</span><span class="s1"> 
    </span><span class="s2">public static double </span><span class="s1">getPenRadius() { </span><span class="s2">return </span><span class="s1">penRadius</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the pen size to the default (.002). 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setPenRadius() { setPenRadius(DEFAULT_PEN_RADIUS)</span><span class="s2">; </span><span class="s1">} 
    </span><span class="s0">/** 
     * Set the radius of the pen to the given size. 
     * @param r the radius of the pen 
     * @throws IllegalArgumentException if r is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setPenRadius(</span><span class="s2">double </span><span class="s1">r) { 
        </span><span class="s2">if </span><span class="s1">(r &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;pen radius must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        penRadius = r</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">float </span><span class="s1">scaledPenRadius = (</span><span class="s2">float</span><span class="s1">) (r * DEFAULT_SIZE)</span><span class="s2">;</span><span class="s1"> 
        BasicStroke stroke = </span><span class="s2">new </span><span class="s1">BasicStroke(scaledPenRadius</span><span class="s2">, </span><span class="s1">BasicStroke.CAP_ROUND</span><span class="s2">, </span><span class="s1">BasicStroke.JOIN_ROUND)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s3">// BasicStroke stroke = new BasicStroke(scaledPenRadius);</span><span class="s1"> 
        offscreen.setStroke(stroke)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Get the current pen color. 
     */</span><span class="s1"> 
    </span><span class="s2">public static </span><span class="s1">Color getPenColor() { </span><span class="s2">return </span><span class="s1">penColor</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the pen color to the default color (black). 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setPenColor() { setPenColor(DEFAULT_PEN_COLOR)</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the pen color to the given color. The available pen colors are 
     * BLACK, BLUE, CYAN, DARK_GRAY, GRAY, GREEN, LIGHT_GRAY, MAGENTA, 
     * ORANGE, PINK, RED, WHITE, and YELLOW. 
     * @param color the Color to make the pen 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setPenColor(Color color) { 
        penColor = color</span><span class="s2">;</span><span class="s1"> 
        offscreen.setColor(penColor)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Set the pen color to the given RGB color. 
     * @param red the amount of red (between 0 and 255) 
     * @param green the amount of green (between 0 and 255) 
     * @param blue the amount of blue (between 0 and 255) 
     * @throws IllegalArgumentException if the amount of red, green, or blue are outside prescribed range 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setPenColor(</span><span class="s2">int </span><span class="s1">red</span><span class="s2">, int </span><span class="s1">green</span><span class="s2">, int </span><span class="s1">blue) { 
        </span><span class="s2">if </span><span class="s1">(red   &lt; </span><span class="s4">0 </span><span class="s1">|| red   &gt;= </span><span class="s4">256</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;amount of red must be between 0 and 255&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(green &lt; </span><span class="s4">0 </span><span class="s1">|| green &gt;= </span><span class="s4">256</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;amount of red must be between 0 and 255&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(blue  &lt; </span><span class="s4">0 </span><span class="s1">|| blue  &gt;= </span><span class="s4">256</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;amount of red must be between 0 and 255&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        setPenColor(</span><span class="s2">new </span><span class="s1">Color(red</span><span class="s2">, </span><span class="s1">green</span><span class="s2">, </span><span class="s1">blue))</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Get the current font. 
     */</span><span class="s1"> 
    </span><span class="s2">public static </span><span class="s1">Font getFont() { </span><span class="s2">return </span><span class="s1">font</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the font to the default font (sans serif, 16 point). 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setFont() { setFont(DEFAULT_FONT)</span><span class="s2">; </span><span class="s1">} 
 
    </span><span class="s0">/** 
     * Set the font to the given value. 
     * @param f the font to make text 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">setFont(Font f) { font = f</span><span class="s2">; </span><span class="s1">} 
 
 
   </span><span class="s0">/************************************************************************* 
    *  Drawing geometric shapes. 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Draw a line from (x0, y0) to (x1, y1). 
     * @param x0 the x-coordinate of the starting point 
     * @param y0 the y-coordinate of the starting point 
     * @param x1 the x-coordinate of the destination point 
     * @param y1 the y-coordinate of the destination point 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">line(</span><span class="s2">double </span><span class="s1">x0</span><span class="s2">, double </span><span class="s1">y0</span><span class="s2">, double </span><span class="s1">x1</span><span class="s2">, double </span><span class="s1">y1) { 
        offscreen.draw(</span><span class="s2">new </span><span class="s1">Line2D.Double(scaleX(x0)</span><span class="s2">, </span><span class="s1">scaleY(y0)</span><span class="s2">, </span><span class="s1">scaleX(x1)</span><span class="s2">, </span><span class="s1">scaleY(y1)))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw one pixel at (x, y). 
     * @param x the x-coordinate of the pixel 
     * @param y the y-coordinate of the pixel 
     */</span><span class="s1"> 
    </span><span class="s2">private static void </span><span class="s1">pixel(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y) { 
        offscreen.fillRect((</span><span class="s2">int</span><span class="s1">) Math.round(scaleX(x))</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(scaleY(y))</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw a point at (x, y). 
     * @param x the x-coordinate of the point 
     * @param y the y-coordinate of the point 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">point(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y) { 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">r = penRadius</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">float </span><span class="s1">scaledPenRadius = (</span><span class="s2">float</span><span class="s1">) (r * DEFAULT_SIZE)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// double ws = factorX(2*r);</span><span class="s1"> 
        </span><span class="s3">// double hs = factorY(2*r);</span><span class="s1"> 
        </span><span class="s3">// if (ws &lt;= 1 &amp;&amp; hs &lt;= 1) pixel(x, y);</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(scaledPenRadius &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.fill(</span><span class="s2">new </span><span class="s1">Ellipse2D.Double(xs - scaledPenRadius/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - scaledPenRadius/</span><span class="s4">2</span><span class="s2">,</span><span class="s1"> 
                                                 scaledPenRadius</span><span class="s2">, </span><span class="s1">scaledPenRadius))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw a circle of radius r, centered on (x, y). 
     * @param x the x-coordinate of the center of the circle 
     * @param y the y-coordinate of the center of the circle 
     * @param r the radius of the circle 
     * @throws IllegalArgumentException if the radius of the circle is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">circle(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">r) { 
        </span><span class="s2">if </span><span class="s1">(r &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;circle radius must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.draw(</span><span class="s2">new </span><span class="s1">Ellipse2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw filled circle of radius r, centered on (x, y). 
     * @param x the x-coordinate of the center of the circle 
     * @param y the y-coordinate of the center of the circle 
     * @param r the radius of the circle 
     * @throws IllegalArgumentException if the radius of the circle is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">filledCircle(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">r) { 
        </span><span class="s2">if </span><span class="s1">(r &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;circle radius must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.fill(</span><span class="s2">new </span><span class="s1">Ellipse2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
    </span><span class="s0">/** 
     * Draw an ellipse with given semimajor and semiminor axes, centered on (x, y). 
     * @param x the x-coordinate of the center of the ellipse 
     * @param y the y-coordinate of the center of the ellipse 
     * @param semiMajorAxis is the semimajor axis of the ellipse 
     * @param semiMinorAxis is the semiminor axis of the ellipse 
     * @throws IllegalArgumentException if either of the axes are negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">ellipse(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">semiMajorAxis</span><span class="s2">, double </span><span class="s1">semiMinorAxis) { 
        </span><span class="s2">if </span><span class="s1">(semiMajorAxis &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;ellipse semimajor axis must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(semiMinorAxis &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;ellipse semiminor axis must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*semiMajorAxis)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*semiMinorAxis)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.draw(</span><span class="s2">new </span><span class="s1">Ellipse2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw an ellipse with given semimajor and semiminor axes, centered on (x, y). 
     * @param x the x-coordinate of the center of the ellipse 
     * @param y the y-coordinate of the center of the ellipse 
     * @param semiMajorAxis is the semimajor axis of the ellipse 
     * @param semiMinorAxis is the semiminor axis of the ellipse 
     * @throws IllegalArgumentException if either of the axes are negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">filledEllipse(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">semiMajorAxis</span><span class="s2">, double </span><span class="s1">semiMinorAxis) { 
        </span><span class="s2">if </span><span class="s1">(semiMajorAxis &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;ellipse semimajor axis must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(semiMinorAxis &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;ellipse semiminor axis must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*semiMajorAxis)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*semiMinorAxis)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.fill(</span><span class="s2">new </span><span class="s1">Ellipse2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
    </span><span class="s0">/** 
     * Draw an arc of radius r, centered on (x, y), from angle1 to angle2 (in degrees). 
     * @param x the x-coordinate of the center of the circle 
     * @param y the y-coordinate of the center of the circle 
     * @param r the radius of the circle 
     * @param angle1 the starting angle. 0 would mean an arc beginning at 3 o'clock. 
     * @param angle2 the angle at the end of the arc. For example, if 
     *        you want a 90 degree arc, then angle2 should be angle1 + 90. 
     * @throws IllegalArgumentException if the radius of the circle is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">arc(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">r</span><span class="s2">, double </span><span class="s1">angle1</span><span class="s2">, double </span><span class="s1">angle2) { 
        </span><span class="s2">if </span><span class="s1">(r &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;arc radius must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">(angle2 &lt; angle1) angle2 += </span><span class="s4">360</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.draw(</span><span class="s2">new </span><span class="s1">Arc2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs</span><span class="s2">, </span><span class="s1">angle1</span><span class="s2">, </span><span class="s1">angle2 - angle1</span><span class="s2">, </span><span class="s1">Arc2D.OPEN))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw a square of side length 2r, centered on (x, y). 
     * @param x the x-coordinate of the center of the square 
     * @param y the y-coordinate of the center of the square 
     * @param r radius is half the length of any side of the square 
     * @throws IllegalArgumentException if r is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">square(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">r) { 
        </span><span class="s2">if </span><span class="s1">(r &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;square side length must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.draw(</span><span class="s2">new </span><span class="s1">Rectangle2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw a filled square of side length 2r, centered on (x, y). 
     * @param x the x-coordinate of the center of the square 
     * @param y the y-coordinate of the center of the square 
     * @param r radius is half the length of any side of the square 
     * @throws IllegalArgumentException if r is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">filledSquare(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">r) { 
        </span><span class="s2">if </span><span class="s1">(r &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;square side length must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*r)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.fill(</span><span class="s2">new </span><span class="s1">Rectangle2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
    </span><span class="s0">/** 
     * Draw a rectangle of given half width and half height, centered on (x, y). 
     * @param x the x-coordinate of the center of the rectangle 
     * @param y the y-coordinate of the center of the rectangle 
     * @param halfWidth is half the width of the rectangle 
     * @param halfHeight is half the height of the rectangle 
     * @throws IllegalArgumentException if halfWidth or halfHeight is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">rectangle(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">halfWidth</span><span class="s2">, double </span><span class="s1">halfHeight) { 
        </span><span class="s2">if </span><span class="s1">(halfWidth  &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;half width must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(halfHeight &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;half height must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*halfWidth)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*halfHeight)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.draw(</span><span class="s2">new </span><span class="s1">Rectangle2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw a filled rectangle of given half width and half height, centered on (x, y). 
     * @param x the x-coordinate of the center of the rectangle 
     * @param y the y-coordinate of the center of the rectangle 
     * @param halfWidth is half the width of the rectangle 
     * @param halfHeight is half the height of the rectangle 
     * @throws IllegalArgumentException if halfWidth or halfHeight is negative 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">filledRectangle(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, double </span><span class="s1">halfWidth</span><span class="s2">, double </span><span class="s1">halfHeight) { 
        </span><span class="s2">if </span><span class="s1">(halfWidth  &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;half width must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(halfHeight &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;half height must be nonnegative&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(</span><span class="s4">2</span><span class="s1">*halfWidth)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(</span><span class="s4">2</span><span class="s1">*halfHeight)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">offscreen.fill(</span><span class="s2">new </span><span class="s1">Rectangle2D.Double(xs - ws/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ys - hs/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
    </span><span class="s0">/** 
     * Draw a polygon with the given (x[i], y[i]) coordinates. 
     * @param x an array of all the x-coordindates of the polygon 
     * @param y an array of all the y-coordindates of the polygon 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">polygon(</span><span class="s2">double</span><span class="s1">[] x</span><span class="s2">, double</span><span class="s1">[] y) { 
        </span><span class="s2">int </span><span class="s1">N = x.length</span><span class="s2">;</span><span class="s1"> 
        GeneralPath path = </span><span class="s2">new </span><span class="s1">GeneralPath()</span><span class="s2">;</span><span class="s1"> 
        path.moveTo((</span><span class="s2">float</span><span class="s1">) scaleX(x[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) scaleY(y[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; N</span><span class="s2">; </span><span class="s1">i++) 
            path.lineTo((</span><span class="s2">float</span><span class="s1">) scaleX(x[i])</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) scaleY(y[i]))</span><span class="s2">;</span><span class="s1"> 
        path.closePath()</span><span class="s2">;</span><span class="s1"> 
        offscreen.draw(path)</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw a filled polygon with the given (x[i], y[i]) coordinates. 
     * @param x an array of all the x-coordindates of the polygon 
     * @param y an array of all the y-coordindates of the polygon 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">filledPolygon(</span><span class="s2">double</span><span class="s1">[] x</span><span class="s2">, double</span><span class="s1">[] y) { 
        </span><span class="s2">int </span><span class="s1">N = x.length</span><span class="s2">;</span><span class="s1"> 
        GeneralPath path = </span><span class="s2">new </span><span class="s1">GeneralPath()</span><span class="s2">;</span><span class="s1"> 
        path.moveTo((</span><span class="s2">float</span><span class="s1">) scaleX(x[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) scaleY(y[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; N</span><span class="s2">; </span><span class="s1">i++) 
            path.lineTo((</span><span class="s2">float</span><span class="s1">) scaleX(x[i])</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) scaleY(y[i]))</span><span class="s2">;</span><span class="s1"> 
        path.closePath()</span><span class="s2">;</span><span class="s1"> 
        offscreen.fill(path)</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
 
   </span><span class="s0">/************************************************************************* 
    *  Drawing images. 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s3">// get an image from the given filename</span><span class="s1"> 
    </span><span class="s2">private static </span><span class="s1">Image getImage(String filename) { 
 
        </span><span class="s3">// to read from file</span><span class="s1"> 
        ImageIcon icon = </span><span class="s2">new </span><span class="s1">ImageIcon(filename)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// try to read from URL</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">((icon == </span><span class="s2">null</span><span class="s1">) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) { 
            </span><span class="s2">try </span><span class="s1">{ 
                URL url = </span><span class="s2">new </span><span class="s1">URL(filename)</span><span class="s2">;</span><span class="s1"> 
                icon = </span><span class="s2">new </span><span class="s1">ImageIcon(url)</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(Exception e) { </span><span class="s6">/* not a url */ </span><span class="s1">} 
        } 
 
        </span><span class="s3">// in case file is inside a .jar</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">((icon == </span><span class="s2">null</span><span class="s1">) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) { 
            URL url = StdDraw.</span><span class="s2">class</span><span class="s1">.getResource(filename)</span><span class="s2">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">(url == </span><span class="s2">null</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;image &quot; </span><span class="s1">+ filename + </span><span class="s5">&quot; not found&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            icon = </span><span class="s2">new </span><span class="s1">ImageIcon(url)</span><span class="s2">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">icon.getImage()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw picture (gif, jpg, or png) centered on (x, y). 
     * @param x the center x-coordinate of the image 
     * @param y the center y-coordinate of the image 
     * @param s the name of the image/picture, e.g., &quot;ball.gif&quot; 
     * @throws IllegalArgumentException if the image is corrupt 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">picture(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s) { 
        Image image = getImage(s)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">ws = image.getWidth(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">hs = image.getHeight(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt; </span><span class="s4">0 </span><span class="s1">|| hs &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;image &quot; </span><span class="s1">+ s + </span><span class="s5">&quot; is corrupt&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        offscreen.drawImage(image</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(xs - ws/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(ys - hs/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw picture (gif, jpg, or png) centered on (x, y), 
     * rotated given number of degrees 
     * @param x the center x-coordinate of the image 
     * @param y the center y-coordinate of the image 
     * @param s the name of the image/picture, e.g., &quot;ball.gif&quot; 
     * @param degrees is the number of degrees to rotate counterclockwise 
     * @throws IllegalArgumentException if the image is corrupt 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">picture(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s</span><span class="s2">, double </span><span class="s1">degrees) { 
        Image image = getImage(s)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">ws = image.getWidth(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">hs = image.getHeight(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt; </span><span class="s4">0 </span><span class="s1">|| hs &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;image &quot; </span><span class="s1">+ s + </span><span class="s5">&quot; is corrupt&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        offscreen.rotate(Math.toRadians(-degrees)</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">;</span><span class="s1"> 
        offscreen.drawImage(image</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(xs - ws/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(ys - hs/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        offscreen.rotate(Math.toRadians(+degrees)</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">;</span><span class="s1"> 
 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Draw picture (gif, jpg, or png) centered on (x, y), rescaled to w-by-h. 
     * @param x the center x coordinate of the image 
     * @param y the center y coordinate of the image 
     * @param s the name of the image/picture, e.g., &quot;ball.gif&quot; 
     * @param w the width of the image 
     * @param h the height of the image 
     * @throws IllegalArgumentException if the width height are negative 
     * @throws IllegalArgumentException if the image is corrupt 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">picture(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s</span><span class="s2">, double </span><span class="s1">w</span><span class="s2">, double </span><span class="s1">h) { 
        Image image = getImage(s)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(w &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;width is negative: &quot; </span><span class="s1">+ w)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(h &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;height is negative: &quot; </span><span class="s1">+ h)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(w)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(h)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt; </span><span class="s4">0 </span><span class="s1">|| hs &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;image &quot; </span><span class="s1">+ s + </span><span class="s5">&quot; is corrupt&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">else </span><span class="s1">{ 
            offscreen.drawImage(image</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(xs - ws/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                                       (</span><span class="s2">int</span><span class="s1">) Math.round(ys - hs/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                                       (</span><span class="s2">int</span><span class="s1">) Math.round(ws)</span><span class="s2">,</span><span class="s1"> 
                                       (</span><span class="s2">int</span><span class="s1">) Math.round(hs)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        } 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
    </span><span class="s0">/** 
     * Draw picture (gif, jpg, or png) centered on (x, y), rotated 
     * given number of degrees, rescaled to w-by-h. 
     * @param x the center x-coordinate of the image 
     * @param y the center y-coordinate of the image 
     * @param s the name of the image/picture, e.g., &quot;ball.gif&quot; 
     * @param w the width of the image 
     * @param h the height of the image 
     * @param degrees is the number of degrees to rotate counterclockwise 
     * @throws IllegalArgumentException if the image is corrupt 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">picture(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s</span><span class="s2">, double </span><span class="s1">w</span><span class="s2">, double </span><span class="s1">h</span><span class="s2">, double </span><span class="s1">degrees) { 
        Image image = getImage(s)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ws = factorX(w)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">hs = factorY(h)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt; </span><span class="s4">0 </span><span class="s1">|| hs &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span><span class="s5">&quot;image &quot; </span><span class="s1">+ s + </span><span class="s5">&quot; is corrupt&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(ws &lt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; hs &lt;= </span><span class="s4">1</span><span class="s1">) pixel(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
 
        offscreen.rotate(Math.toRadians(-degrees)</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">;</span><span class="s1"> 
        offscreen.drawImage(image</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.round(xs - ws/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                                   (</span><span class="s2">int</span><span class="s1">) Math.round(ys - hs/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                                   (</span><span class="s2">int</span><span class="s1">) Math.round(ws)</span><span class="s2">,</span><span class="s1"> 
                                   (</span><span class="s2">int</span><span class="s1">) Math.round(hs)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        offscreen.rotate(Math.toRadians(+degrees)</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">;</span><span class="s1"> 
 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
   </span><span class="s0">/************************************************************************* 
    *  Drawing text. 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Write the given text string in the current font, centered on (x, y). 
     * @param x the center x-coordinate of the text 
     * @param y the center y-coordinate of the text 
     * @param s the text 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">text(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s) { 
        offscreen.setFont(font)</span><span class="s2">;</span><span class="s1"> 
        FontMetrics metrics = offscreen.getFontMetrics()</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">ws = metrics.stringWidth(s)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">hs = metrics.getDescent()</span><span class="s2">;</span><span class="s1"> 
        offscreen.drawString(s</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) (xs - ws/</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) (ys + hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Write the given text string in the current font, centered on (x, y) and 
     * rotated by the specified number of degrees   
     * @param x the center x-coordinate of the text 
     * @param y the center y-coordinate of the text 
     * @param s the text 
     * @param degrees is the number of degrees to rotate counterclockwise 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">text(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s</span><span class="s2">, double </span><span class="s1">degrees) { 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        offscreen.rotate(Math.toRadians(-degrees)</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">;</span><span class="s1"> 
        text(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">;</span><span class="s1"> 
        offscreen.rotate(Math.toRadians(+degrees)</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
    </span><span class="s0">/** 
     * Write the given text string in the current font, left-aligned at (x, y). 
     * @param x the x-coordinate of the text 
     * @param y the y-coordinate of the text 
     * @param s the text 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">textLeft(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s) { 
        offscreen.setFont(font)</span><span class="s2">;</span><span class="s1"> 
        FontMetrics metrics = offscreen.getFontMetrics()</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">hs = metrics.getDescent()</span><span class="s2">;</span><span class="s1"> 
        offscreen.drawString(s</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) (xs)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) (ys + hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Write the given text string in the current font, right-aligned at (x, y). 
     * @param x the x-coordinate of the text 
     * @param y the y-coordinate of the text 
     * @param s the text 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">textRight(</span><span class="s2">double </span><span class="s1">x</span><span class="s2">, double </span><span class="s1">y</span><span class="s2">, </span><span class="s1">String s) { 
        offscreen.setFont(font)</span><span class="s2">;</span><span class="s1"> 
        FontMetrics metrics = offscreen.getFontMetrics()</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">xs = scaleX(x)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double </span><span class="s1">ys = scaleY(y)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">ws = metrics.stringWidth(s)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">int </span><span class="s1">hs = metrics.getDescent()</span><span class="s2">;</span><span class="s1"> 
        offscreen.drawString(s</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) (xs - ws)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">float</span><span class="s1">) (ys + hs))</span><span class="s2">;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
 
    </span><span class="s0">/** 
     * Display on screen, pause for t milliseconds, and turn on 
     * &lt;em&gt;animation mode&lt;/em&gt;: subsequent calls to 
     * drawing methods such as &lt;tt&gt;line()&lt;/tt&gt;, &lt;tt&gt;circle()&lt;/tt&gt;, and &lt;tt&gt;square()&lt;/tt&gt; 
     * will not be displayed on screen until the next call to &lt;tt&gt;show()&lt;/tt&gt;. 
     * This is useful for producing animations (clear the screen, draw a bunch of shapes, 
     * display on screen for a fixed amount of time, and repeat). It also speeds up 
     * drawing a huge number of shapes (call &lt;tt&gt;show(0)&lt;/tt&gt; to defer drawing 
     * on screen, draw the shapes, and call &lt;tt&gt;show(0)&lt;/tt&gt; to display them all 
     * on screen at once). 
     * @param t number of milliseconds 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">show(</span><span class="s2">int </span><span class="s1">t) { 
        defer = </span><span class="s2">false;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">try </span><span class="s1">{ Thread.sleep(t)</span><span class="s2">; </span><span class="s1">} 
        </span><span class="s2">catch </span><span class="s1">(InterruptedException e) { System.out.println(</span><span class="s5">&quot;Error sleeping&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">} 
        defer = </span><span class="s2">true;</span><span class="s1"> 
    } 
 
    </span><span class="s0">/** 
     * Display on-screen and turn off animation mode: 
     * subsequent calls to 
     * drawing methods such as &lt;tt&gt;line()&lt;/tt&gt;, &lt;tt&gt;circle()&lt;/tt&gt;, and &lt;tt&gt;square()&lt;/tt&gt; 
     * will be displayed on screen when called. This is the default. 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">show() { 
        defer = </span><span class="s2">false;</span><span class="s1"> 
        draw()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">// draw onscreen if defer is false</span><span class="s1"> 
    </span><span class="s2">private static void </span><span class="s1">draw() { 
        </span><span class="s2">if </span><span class="s1">(defer) </span><span class="s2">return;</span><span class="s1"> 
        onscreen.drawImage(offscreenImage</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        frame.repaint()</span><span class="s2">;</span><span class="s1"> 
    } 
 
 
   </span><span class="s0">/************************************************************************* 
    *  Save drawing to a file. 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Save onscreen image to file - suffix must be png, jpg, or gif. 
     * @param filename the name of the file with one of the required suffixes 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">save(String filename) { 
        File file = </span><span class="s2">new </span><span class="s1">File(filename)</span><span class="s2">;</span><span class="s1"> 
        String suffix = filename.substring(filename.lastIndexOf(</span><span class="s5">'.'</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// png files</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(suffix.toLowerCase().equals(</span><span class="s5">&quot;png&quot;</span><span class="s1">)) { 
            </span><span class="s2">try </span><span class="s1">{ ImageIO.write(onscreenImage</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">file)</span><span class="s2">; </span><span class="s1">} 
            </span><span class="s2">catch </span><span class="s1">(IOException e) { e.printStackTrace()</span><span class="s2">; </span><span class="s1">} 
        } 
 
        </span><span class="s3">// need to change from ARGB to RGB for jpeg</span><span class="s1"> 
        </span><span class="s3">// reference: http://archives.java.sun.com/cgi-bin/wa?A2=ind0404&amp;L=java2d-interest&amp;D=0&amp;P=2727</span><span class="s1"> 
        </span><span class="s2">else if </span><span class="s1">(suffix.toLowerCase().equals(</span><span class="s5">&quot;jpg&quot;</span><span class="s1">)) { 
            WritableRaster raster = onscreenImage.getRaster()</span><span class="s2">;</span><span class="s1"> 
            WritableRaster newRaster</span><span class="s2">;</span><span class="s1"> 
            newRaster = raster.createWritableChild(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, new int</span><span class="s1">[] {</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">})</span><span class="s2">;</span><span class="s1"> 
            DirectColorModel cm = (DirectColorModel) onscreenImage.getColorModel()</span><span class="s2">;</span><span class="s1"> 
            DirectColorModel newCM = </span><span class="s2">new </span><span class="s1">DirectColorModel(cm.getPixelSize()</span><span class="s2">,</span><span class="s1"> 
                                                          cm.getRedMask()</span><span class="s2">,</span><span class="s1"> 
                                                          cm.getGreenMask()</span><span class="s2">,</span><span class="s1"> 
                                                          cm.getBlueMask())</span><span class="s2">;</span><span class="s1"> 
            BufferedImage rgbBuffer = </span><span class="s2">new </span><span class="s1">BufferedImage(newCM</span><span class="s2">, </span><span class="s1">newRaster</span><span class="s2">, false,  null</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ ImageIO.write(rgbBuffer</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">file)</span><span class="s2">; </span><span class="s1">} 
            </span><span class="s2">catch </span><span class="s1">(IOException e) { e.printStackTrace()</span><span class="s2">; </span><span class="s1">} 
        } 
 
        </span><span class="s2">else </span><span class="s1">{ 
            System.out.println(</span><span class="s5">&quot;Invalid image file type: &quot; </span><span class="s1">+ suffix)</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">actionPerformed(ActionEvent e) { 
        FileDialog chooser = </span><span class="s2">new </span><span class="s1">FileDialog(StdDraw.frame</span><span class="s2">, </span><span class="s5">&quot;Use a .png or .jpg extension&quot;</span><span class="s2">, </span><span class="s1">FileDialog.SAVE)</span><span class="s2">;</span><span class="s1"> 
        chooser.setVisible(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        String filename = chooser.getFile()</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(filename != </span><span class="s2">null</span><span class="s1">) { 
            StdDraw.save(chooser.getDirectory() + File.separator + chooser.getFile())</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
 
   </span><span class="s0">/************************************************************************* 
    *  Mouse interactions. 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Is the mouse being pressed? 
     * @return true or false 
     */</span><span class="s1"> 
    </span><span class="s2">public static boolean </span><span class="s1">mousePressed() { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            </span><span class="s2">return </span><span class="s1">mousePressed</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * What is the x-coordinate of the mouse? 
     * @return the value of the x-coordinate of the mouse 
     */</span><span class="s1"> 
    </span><span class="s2">public static double </span><span class="s1">mouseX() { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            </span><span class="s2">return </span><span class="s1">mouseX</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * What is the y-coordinate of the mouse? 
     * @return the value of the y-coordinate of the mouse 
     */</span><span class="s1"> 
    </span><span class="s2">public static double </span><span class="s1">mouseY() { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            </span><span class="s2">return </span><span class="s1">mouseY</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mouseClicked(MouseEvent e) { } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mouseEntered(MouseEvent e) { } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mouseExited(MouseEvent e) { } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mousePressed(MouseEvent e) { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            mouseX = StdDraw.userX(e.getX())</span><span class="s2">;</span><span class="s1"> 
            mouseY = StdDraw.userY(e.getY())</span><span class="s2">;</span><span class="s1"> 
            mousePressed = </span><span class="s2">true;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mouseReleased(MouseEvent e) { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            mousePressed = </span><span class="s2">false;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mouseDragged(MouseEvent e)  { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            mouseX = StdDraw.userX(e.getX())</span><span class="s2">;</span><span class="s1"> 
            mouseY = StdDraw.userY(e.getY())</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">mouseMoved(MouseEvent e) { 
        </span><span class="s2">synchronized </span><span class="s1">(mouseLock) { 
            mouseX = StdDraw.userX(e.getX())</span><span class="s2">;</span><span class="s1"> 
            mouseY = StdDraw.userY(e.getY())</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
 
   </span><span class="s0">/************************************************************************* 
    *  Keyboard interactions. 
    *************************************************************************/</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * Has the user typed a key? 
     * @return true if the user has typed a key, false otherwise 
     */</span><span class="s1"> 
    </span><span class="s2">public static boolean </span><span class="s1">hasNextKeyTyped() { 
        </span><span class="s2">synchronized </span><span class="s1">(keyLock) { 
            </span><span class="s2">return </span><span class="s1">!keysTyped.isEmpty()</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * What is the next key that was typed by the user? This method returns 
     * a Unicode character corresponding to the key typed (such as 'a' or 'A'). 
     * It cannot identify action keys (such as F1 
     * and arrow keys) or modifier keys (such as control). 
     * @return the next Unicode key typed 
     */</span><span class="s1"> 
    </span><span class="s2">public static char </span><span class="s1">nextKeyTyped() { 
        </span><span class="s2">synchronized </span><span class="s1">(keyLock) { 
            </span><span class="s2">return </span><span class="s1">keysTyped.removeLast()</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * Is the keycode currently being pressed? This method takes as an argument 
     * the keycode (corresponding to a physical key). It can handle action keys 
     * (such as F1 and arrow keys) and modifier keys (such as shift and control). 
     * See &lt;a href = &quot;http://download.oracle.com/javase/6/docs/api/java/awt/event/KeyEvent.html&quot;&gt;KeyEvent.java&lt;/a&gt; 
     * for a description of key codes. 
     * @return true if keycode is currently being pressed, false otherwise 
     */</span><span class="s1"> 
    </span><span class="s2">public static boolean </span><span class="s1">isKeyPressed(</span><span class="s2">int </span><span class="s1">keycode) { 
        </span><span class="s2">synchronized </span><span class="s1">(keyLock) { 
            </span><span class="s2">return </span><span class="s1">keysDown.contains(keycode)</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">keyTyped(KeyEvent e) { 
        </span><span class="s2">synchronized </span><span class="s1">(keyLock) { 
            keysTyped.addFirst(e.getKeyChar())</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">keyPressed(KeyEvent e) { 
        </span><span class="s2">synchronized </span><span class="s1">(keyLock) { 
            keysDown.add(e.getKeyCode())</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/** 
     * This method cannot be called directly. 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">keyReleased(KeyEvent e) { 
        </span><span class="s2">synchronized </span><span class="s1">(keyLock) { 
            keysDown.remove(e.getKeyCode())</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
 
 
 
    </span><span class="s0">/** 
     * Test client. 
     */</span><span class="s1"> 
    </span><span class="s2">public static void </span><span class="s1">main(String[] args) { 
        StdDraw.square(</span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.1</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.filledSquare(</span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.2</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.circle(</span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.2</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        StdDraw.setPenColor(StdDraw.BOOK_RED)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.setPenRadius(</span><span class="s4">.02</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.arc(</span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.1</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">45</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// draw a blue diamond</span><span class="s1"> 
        StdDraw.setPenRadius()</span><span class="s2">;</span><span class="s1"> 
        StdDraw.setPenColor(StdDraw.BOOK_BLUE)</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double</span><span class="s1">[] x = { </span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.2 </span><span class="s1">}</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">double</span><span class="s1">[] y = { </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.1 </span><span class="s1">}</span><span class="s2">;</span><span class="s1"> 
        StdDraw.filledPolygon(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s3">// text</span><span class="s1"> 
        StdDraw.setPenColor(StdDraw.BLACK)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.text(</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s5">&quot;black text&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.setPenColor(StdDraw.WHITE)</span><span class="s2">;</span><span class="s1"> 
        StdDraw.text(</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s5">&quot;white text&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
    } 
 
} 
</span></pre>
</body>
</html>